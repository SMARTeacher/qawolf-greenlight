"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pollCiGreenlightStatus = pollCiGreenlightStatus;
const ci_greenlight_1 = require("../../api/ci-greenlight");
const utils_1 = require("../../utils");
// If you change these values, make sure you update the JSDoc
// comments in the PollConfig type.
const safeDefaults = {
    maxRetries: 10,
    pollTimeout: 120 * 60 * 1000,
    retryInterval: 10 * 1000,
    runInProgressInterval: 30 * 1000,
    runUnderReviewInterval: 60 * 1000,
};
async function pollCiGreenlightStatus(deps, apiConfig, { runId, onRunStageChanged: onRunStageChanged = () => void 0, ...pollConfig }) {
    let retries = 0;
    const { log } = deps;
    const { maxRetries = safeDefaults.maxRetries, retryInterval = safeDefaults.retryInterval, runInProgressInterval = safeDefaults.runInProgressInterval, runUnderReviewInterval = safeDefaults.runUnderReviewInterval, pollTimeout = safeDefaults.pollTimeout, } = pollConfig;
    let currentStatus = undefined;
    const startedAt = Date.now();
    let hasTimedOut = false;
    while (!(hasTimedOut = Date.now() - startedAt > pollTimeout)) {
        const responseState = await (0, ci_greenlight_1.fetchCiGreenlightStatus)(apiConfig, {
            runId,
        }, deps);
        if (!responseState.ok && !responseState.canRetry) {
            log.error(`üö´ Unrecoverable error (status ${responseState.httpStatus}) from CI greenlight, aborting.`);
            return {
                abortReason: "4XX-client-error",
                httpStatus: responseState.httpStatus,
                outcome: "aborted",
            };
        }
        if (!responseState.ok) {
            // This is a non-OK retryable status.
            retries += 1;
            if (retries > maxRetries) {
                log.error(`üö´ Unrecoverable error${responseState.httpStatus
                    ? ` (status ${responseState.httpStatus})`
                    : ""} from CI greenlight, aborting after ${maxRetries} attempts.`);
                if (responseState.errorType === "network")
                    return {
                        abortReason: "network-error",
                        httpStatus: undefined,
                        outcome: "aborted",
                    };
                let abortReason = "XXX-other-http-code";
                if (responseState.errorType === "not-found")
                    abortReason = "404-run-not-found";
                else if (responseState.errorType === "server")
                    abortReason = "5XX-server-error";
                else
                    (0, utils_1.assertType)(responseState);
                return {
                    abortReason,
                    httpStatus: responseState.httpStatus,
                    outcome: "aborted",
                };
            }
            const { errorType, httpStatus } = responseState;
            const retryLabel = `${httpStatus ? ` (status ${httpStatus})` : ""}, will try again... (${retries}/${maxRetries})`;
            if (errorType === "network")
                log.warn(`‚ùå Network error${retryLabel}`);
            else if (errorType === "not-found")
                log.info(`‚è≥ Run not found${retryLabel}`);
            else if (errorType === "server")
                log.warn(`‚ùå Server error${retryLabel}`);
            await (0, utils_1.sleep)(retryInterval);
            continue;
        }
        // responseState.ok === true
        retries = 0;
        const { greenlightStatus } = responseState;
        const previousStatus = currentStatus;
        currentStatus = greenlightStatus;
        if (!previousStatus ||
            previousStatus.runStage !== greenlightStatus.runStage)
            try {
                await onRunStageChanged(greenlightStatus, previousStatus);
            }
            catch (e) {
                log.error(`Error in onRunStageChanged callback`, e);
            }
        const urlInfo = `See ${greenlightStatus.relevantRunUrl}`;
        const { greenlight, relevantRunId, relevantRunUrl, relevantRunWithBugsUrl, rootRunId, rootRunUrl, runStage, } = greenlightStatus;
        if (rootRunId !== relevantRunId) {
            log.info(`Root run was superseded:
  - Root: ${rootRunUrl}
  - Superseding: ${relevantRunUrl}`);
        }
        if (runStage === "completed") {
            const { blockingBugsCount, blockingBugUrls = [], nonBlockingBugsCount, nonBlockingBugUrls = [], } = greenlightStatus;
            const blockingBugList = blockingBugUrls
                .map((url) => `\n‚Ä¢ ${url}`)
                .join("");
            const nonBlockingBugList = nonBlockingBugUrls
                .map((url) => `\n‚Ä¢ ${url}`)
                .join("");
            const bugsListInText = `${blockingBugUrls.length > 0 ? `\nBLOCKING BUGS:${blockingBugList}` : ""}${nonBlockingBugUrls.length > 0
                ? `\nNON BLOCKING BUGS:${nonBlockingBugList}`
                : ""}`;
            if (greenlight) {
                log.info(`‚úÖ Run passed and no blocking bugs found${nonBlockingBugsCount > 0
                    ? ` and ${nonBlockingBugsCount} non-blocking bug${(0, utils_1.pluralize)(nonBlockingBugsCount)} found`
                    : ""}.\n${urlInfo}`);
                return { greenlightStatus, outcome: "success" };
            }
            else {
                log.warn(`‚ùå Run failed and ${blockingBugsCount} blocking bug${(0, utils_1.pluralize)(blockingBugsCount)} found${nonBlockingBugsCount
                    ? ` and ${nonBlockingBugsCount} non-blocking bug${(0, utils_1.pluralize)(nonBlockingBugsCount)}`
                    : ""}.\nSee ${relevantRunWithBugsUrl}\n` +
                    "You may review the priority of certain bugs to mark these non-blocking and retry the job.\n" +
                    bugsListInText);
                return { greenlightStatus, outcome: "failed" };
            }
        }
        if (runStage === "canceled") {
            log.info(`üö´ Run was canceled. Aborting... Please contact support.\n${urlInfo}`);
            return {
                abortReason: "run-canceled",
                httpStatus: undefined,
                outcome: "aborted",
            };
        }
        // Non-terminal run stages
        if (hasTimedOut) {
            log.warn(`‚ùå Poll timed out after ${pollTimeout / 1000}s. Aborting...`);
            return {
                abortReason: "poll-timed-out",
                httpStatus: undefined,
                outcome: "aborted",
            };
        }
        if (runStage === "initializing") {
            log.info(`‚è≥ Run is in progress... ${urlInfo}`);
            await (0, utils_1.sleep)(runInProgressInterval);
        }
        else if (runStage === "underReview") {
            log.info(`üïµÔ∏è  Run is under review... ${urlInfo}`);
            await (0, utils_1.sleep)(runUnderReviewInterval);
        }
        else {
            (0, utils_1.assertType)(runStage);
            throw new Error(`Unexpected run stage: ${runStage}`);
        }
    }
    log.warn(`‚ùå Poll timed out after ${pollTimeout / 1000}s. Aborting...`);
    return {
        abortReason: "poll-timed-out",
        httpStatus: undefined,
        outcome: "aborted",
    };
}
//# sourceMappingURL=poll-ci-greenlight.js.map